import fenics as fe
from fenics import (Function, FunctionSpace, UnitSquareMesh)
import mshr
import numpy as np
from scipy.spatial import KDTree

def random_function(
        function,
        mesh=None,
        fs=None,
        vals=None,
        mu=1.0,
        sigma=0.01,
        h = None, 
        tol=1e-10,
        f=(lambda x: 2*x**3 - 3*x**2 + 1)
):
    """define a pseudorandom Function

    random_function defines a scalar-valued FEniCS Function that has
    psedorandom values at points on a rectangular grid, and that is
    continuous and differentiable everywhere.

    Required positional argument:
    function: a FEniCS scalar-valeud function, in which will be
        returned the desired function.

    Keyword arguments:
    mesh: the mesh on whose vertices the random values are to be
        imposed. (If not provided, this will be extracted from
        function.) The vertexes of this mesh must be a regular square
        array with equal spacing in all dimensions. The mesh need not
        be that on which function is defined, but its vertexes should
        be a subset of those of the mesh on which function is defined.
    fs: The FunctionSpace on which function is defined. (If not
        provided, this will be extracted from function.) This
        FunctionSpace should have order at least 3.
    vals: The values the function is to take on at each vertex. (The
        ordering is that returned by mesh.coordinates().) If not
        provided, random normal variates are drawn.
    mu=1.0: the mean of the normal distribution
    sigma=0.01: the standard deviation of the normal distribution.
    tol=1e-10: a tolerance for floating-point arithmetic errors.
    f=(lambda x: 2*x**3 - 3*x**2 + 1): the function used to fill in the
        space between the vertexes. 
    """
    if not fs:
        fs = function.function_space()
    if not mesh:
        mesh = fs.mesh()
    dofmap = fs.dofmap()
    gdim = mesh.geometry().dim()
    dcoords = fs.tabulate_dof_coordinates().reshape(-1, gdim)
    tree = KDTree(dcoords)
    dvec = np.zeros(len(dcoords), dtype=float)
    vertexes = mesh.num_vertices()
    vcoords = mesh.coordinates()
    if not h:
        hs = np.array([ 
            np.linalg.norm(mesh.coordinates()[u] - mesh.coordinates()[v]) 
            for u in mesh.cells()[0] for v in mesh.cells()[0]
        ])
        h = np.min(hs[hs > 0])        
    if not vals:
        vals = np.random.normal(mu, sigma, vertexes)
    vf = lambda x: np.product(f(x))
    print(
        'rank', fe.mpi_comm_world().rank,
        'dcoords', dcoords,
        'vcoords', vcoords,
        flush=True)
    for v, vc in enumerate(vcoords):
        touched = np.array(tree.query_ball_point(vc, h, float('inf')))
        print(
            'rank', fe.mpi_comm_world().rank,
            'v', v,
            'vc', vc,
            'touched', touched,
            flush=True)
        if len(touched) > 0:                    # there may be none
            x = np.abs(dcoords[touched] - vc) / h
            touched2 = np.where(np.amax(x, 1) < 1 - tol)[0]
            touched = touched[touched2]
            dvec[touched] += vals[v] * np.fromiter(map(vf, x[touched2]), float)
    function.vector()[:] = dvec
    function.vector().apply('insert')
    return function


def main():
    degree = 3
    mesh = UnitSquareMesh(2, 2)
    gdim = mesh.geometry().dim()
    fs = FunctionSpace(mesh, 'CG', degree)
    f = Function(fs)
    random_function(f)
    print(f.vector().array())

if __name__ == '__main__':
    main()
